<script src="http://www.google.com/jsapi" type="text/javascript"></script>
<script type="text/javascript">google.load("jquery", "1.3.2");</script>

<style type="text/css">
  #bannerimage {
    width: 100%;
    background-image: url("./resources/images/hw_banner_safe_mppi_v5.png");
    height: 300px;
    background-color: rgb(255, 255, 255);
    background-position: center;
    background-size: contain;
    background-repeat: no-repeat;
  }
  img {
    max-width: 100%;
    max-height: 100%;
}

    body {
        font-family: "HelveticaNeue-Light", "Helvetica Neue Light", "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif;
        font-weight:300;
        font-size:18px;
        margin-left: auto;
        margin-right: auto;
        width: 1100px;
    }

    h1, h2 {
        font-weight:300;
    }

    .disclaimerbox {
        background-color: #eee;
        border: 1px solid #eeeeee;
        border-radius: 10px ;
        -moz-border-radius: 10px ;
        -webkit-border-radius: 10px ;
        padding: 20px;
    }

    video.header-vid {
        height: 140px;
        border: 1px solid black;
        border-radius: 10px ;
        -moz-border-radius: 10px ;
        -webkit-border-radius: 10px ;
    }

    img.header-img {
        height: 140px;
        border: 1px solid black;
        border-radius: 10px ;
        -moz-border-radius: 10px ;
        -webkit-border-radius: 10px ;
    }

    img.rounded {
        border: 1px solid #eeeeee;
        border-radius: 10px ;
        -moz-border-radius: 10px ;
        -webkit-border-radius: 10px ;
    }

    a:link,a:visited
    {
        color: #1367a7;
        text-decoration: none;
    }
    a:hover {
        color: #208799;
    }

    td.dl-link {
        height: 160px;
        text-align: center;
        font-size: 22px;
    }

    .layered-paper-big { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
        box-shadow:
                0px 0px 1px 1px rgba(0,0,0,0.35), /* The top layer shadow */
                5px 5px 0 0px #fff, /* The second layer */
                5px 5px 1px 1px rgba(0,0,0,0.35), /* The second layer shadow */
                10px 10px 0 0px #fff, /* The third layer */
                10px 10px 1px 1px rgba(0,0,0,0.35), /* The third layer shadow */
                15px 15px 0 0px #fff, /* The fourth layer */
                15px 15px 1px 1px rgba(0,0,0,0.35), /* The fourth layer shadow */
                20px 20px 0 0px #fff, /* The fifth layer */
                20px 20px 1px 1px rgba(0,0,0,0.35), /* The fifth layer shadow */
                25px 25px 0 0px #fff, /* The fifth layer */
                25px 25px 1px 1px rgba(0,0,0,0.35); /* The fifth layer shadow */
        margin-left: 10px;
        margin-right: 45px;
    }


    .layered-paper { /* modified from: http://css-tricks.com/snippets/css/layered-paper/ */
        box-shadow:
                0px 0px 1px 1px rgba(0,0,0,0.35), /* The top layer shadow */
                5px 5px 0 0px #fff, /* The second layer */
                5px 5px 1px 1px rgba(0,0,0,0.35), /* The second layer shadow */
                10px 10px 0 0px #fff, /* The third layer */
                10px 10px 1px 1px rgba(0,0,0,0.35); /* The third layer shadow */
        margin-top: 5px;
        margin-left: 10px;
        margin-right: 30px;
        margin-bottom: 5px;
    }

    .vert-cent {
        position: relative;
        top: 50%;
        transform: translateY(-50%);
    }

    hr
    {
        border: 0;
        height: 1.5px;
        background-image: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0));
    }
</style>

<html>
  <head>
        <title>DualGuard MPPI - Safe Optimal Control via Sampling MPC and HJ Reachability</title>
        <meta property="og:title" content="Factored 3D" />
  </head>

  <head>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
    <!--
    <script type="text/javascript" id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    -->          
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
    </script>
    <script type="text/javascript"
      src="http://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
    </script>

  </head>

  <body>
    <div id="bannerimage"></div>
    <br>
    <center>
    <span style="font-size:42px">DualGuard MPPI - Safe Optimal Control via Sampling MPC and HJ Reachability</span>
    </center>

    <br><br>
      <table align=center width=900px>
       <tr>
        <td align=center width=100px>
        <center>
        <span style="font-size:20px"><a href="https://javierborquez.github.io/">Javier Borquez*</a></span>
        </center>
        </td>  

        <td align=center width=100px>
        <center>
        <span style="font-size:20px">Luke Raus<sup>†</sup></a></span>
        </center>
        </td>

        <td align=center width=100px>
        <center>
        <span style="font-size:20px">Yusuf Ciftci*</span>
        </center>
        </td>

           
        <td align=center width=100px>
        <center>
        <span style="font-size:20px"><a href="https://smlbansal.github.io/">Somil Bansal<sup>‡</sup></a></span>
        </center>
        </td>


     </tr>
    </table>

    <br>
    <table align=center width=700px>
       <tr>
        <td align=center width=100px>
        <center>
        <div>*University of Southern California</div>
        <div><sup>†</sup>Olin College of Engineering</div>
        <div><sup>‡</sup>Stanford University</div>
        </center>
        </td>	       
      </tr>
    </table>
    <br>
    <center>
      <span style="font-size:20px">Published: IEEE Robotics and Automation Letters 2025</span>
      </center>
    <br>
       
    <table align=center width=500px>
      <tr>
        <td align=center width=100px><center><span style="font-size:20px">
          <a href="https://arxiv.org/pdf/2502.01924">[pdf]</a></span>
        </center></td>
            <!--
            <td align=center width=100px><center><span style="font-size:20px">
              <a href="">[bibtex]</a></span>
            </center></td>-->  

            <td align=center width=100px><center><span style="font-size:20px">
              <a href="https://github.com/luke-raus/DualGuard-MPPI">[source code]</a></span>
          </center></td>          
      </tr>
    </table>    
        
    <br>

    <hr>
    <center><h1>Abstract</h1></center>

            <p align='justify'>
              Designing controllers that are both safe and performant is inherently challenging.
              This co-optimization can be formulated as a constrained optimal control problem, where the cost function represents the performance criterion and safety is specified as a constraint.
              While sampling-based methods, such as Model Predictive Path Integral (MPPI) control, have shown great promise in tackling complex optimal control problems, they often struggle to enforce safety constraints. 
              To address this limitation, we propose DualGuard-MPPI, a novel framework for solving safety-constrained optimal control problems.
              Our approach integrates Hamilton-Jacobi reachability analysis within the MPPI sampling process to ensure that all generated samples are provably safe for the system. 
              On the one hand, this integration allows DualGuard-MPPI to enforce strict safety constraints; at the same time, it facilitates a more effective exploration of the environment with the same number of samples, reducing the effective sampling variance and leading to better performance optimization.
              Through several simulations and hardware experiments, we demonstrate that the proposed approach achieves much higher performance compared to existing MPPI methods, without compromising safety.
            </p>
<br>
<br>
<hr>        
        <center><h1>Problem Statement</h1></center>

        <p align='justify'>
        Consider an autonomous system with state \( x \in X \subseteq \mathbb{R}^n \) evolving under continuous dynamics \( \dot{x} = f(x, u, d) \), where \( u \in U \) is the control input and \( d \in D \) is a disturbance input, which may model uncertainty or an adversarial influence. The function \( f \) is assumed to be uniformly continuous in \( u \) and \( d \), bounded, and Lipschitz continuous in \( x \) for fixed \( u \), \( d \).
        </p>

        <p align='justify'>
        Let \( \xi_{x,t}^{u,d}(\tau) \) denote the system trajectory at time \( \tau \), initialized at state \( x \) and time \( t \), under control signal \( u(\cdot) \) and disturbance signal \( d(\cdot) \). These signals are measurable functions from time to their respective admissible sets, and are assumed to be piecewise continuous, ensuring the trajectory exists, is unique, and remains continuous for all initial states.
        </p>

        <p align='justify'>
        We are given a failure set \( \mathcal{T} \subset X \), representing unsafe states (e.g., obstacles). This set is encoded by a Lipschitz continuous function \( l(x) \), such that \( \mathcal{T} = \{ x : l(x) \leq 0 \} \). The objective is to design a control policy that minimizes a performance cost while ensuring the state never enters \( \mathcal{T} \), even under worst-case disturbances.
        </p>

        <p align='justify'>
        The cost functional to minimize over trajectories is defined as:
        </p>

        <p align='center'>
        \( S(\xi) = \phi(x(t_f), t_f) + \int_{t_0}^{t_f} \mathcal{L}(x(t), u(t), t)\, dt \)
        </p>

        <p align='justify'>
        Here, \( \phi \) and \( \mathcal{L} \) denote terminal and running costs, respectively, and \( t_f \) is the task horizon. We aim to find a control policy \( u^*(\cdot) \) that minimizes this cost while enforcing safety:
        </p>

        <p align='center'>
        \(
        \begin{aligned}
            u^{*}(\cdot) &= \arg\min_{u(\cdot)} S(\xi_{x,t}^{u,d}, u(\cdot)) \\
            \text{s.t.} \quad \dot{x}(t) &= f(x(t), u(t), d(t)), \\
            l(x(t)) &> 0,\quad u(t) \in U,\quad d(t) \in D,\quad \forall t \in [t, t_f]
        \end{aligned}
        \)
        </p>

        <p align='justify'>
        This constrained optimal control problem is generally non-convex and difficult to solve. In this work, we propose a sampling-based Model Predictive Path Integral (MPPI) method that rigorously enforces safety while optimizing performance.
        </p>

        <hr>
        <center><h1>Background</h1></center>

        <!-- MPPI Section -->
        <h2>Model Predictive Path Integral (MPPI)</h2>

        <p align='justify'>
        Model Predictive Path Integral (MPPI) is a sampling-based control method that optimizes trajectories by perturbing a nominal control sequence with noise and evaluating the resulting system rollouts. Each perturbed trajectory is assigned a cost, and the nominal control is updated as a weighted average of the perturbations, where lower-cost trajectories contribute more, the update is given by:
        </p>

        <p align='center'>
        \[
        u(x,j)^{\ast} \approx u(x,j) + \frac{\sum_{k=1}^{K} \exp\left[-\frac{1}{\lambda}S(\xi_j^k)\right] \delta_j^k}{\sum_{k=1}^{K} \exp\left[-\frac{1}{\lambda}S(\xi_j^k)\right]}
        \]
        </p>

        <p align='justify'>
        This procedure is repeated at every time step. The figure below visualizes the forward-simulated rollouts from sampled noisy control sequences. High-cost (unsafe) rollouts are shown in red, while lower-cost (safer) ones are shown in blue.
        </p>

        <center>
            <img src="./resources/images/mppi_car_sim.png" width="45%">
        </center>

        <p align='justify'>
        By weighting noisy control perturbations based on their associated trajectory cost, MPPI approximates a solution to the constrained optimal control problem introduced above. While it does not enforce hard constraints, it optimizes performance by sampling and refining control sequences that are more likely to yield lower-cost, goal-directed behavior.
        </p>

        <!-- HJ Reachability + Filtering -->
        <h2>HJ Reachability and Safety Filtering</h2>

        <p align='justify'>
        To ensure provable safety, we use Hamilton-Jacobi (HJ) reachability analysis to compute the <i>safe set</i>—the set of all states from which the system can avoid entering unsafe regions (e.g., obstacles), despite worst-case disturbances. This is done by solving a differential game and computing a value function \( V(x) \), whose zero sublevel set defines the boundary of safety.
        </p>

        <p align='justify'>
        From this value function, we can also derive a <i>safe control policy</i> \( u^*_{\text{safe}}(x) \) that guarantees the system remains within the safe set:
        </p>

        <p align='center'>
        \[
        u^*_{\text{safe}}(x) = \arg\max_{u \in U} \min_{d \in D} \nabla V(x) \cdot f(x, u, d)
        \]
        </p>

        <p align='justify'>
        We enforce this safety policy using a <b>Least Restrictive Filter (LRF)</b>: the system follows its nominal control unless it reaches the boundary of the safe set, in which case it switches to the safe control above. This guarantees constraint satisfaction without over-restricting performance. The following figure illustrates the filtering process, where the red trajectory follows a nominal unsafe control, and the blue trajectory the least restrictive filtered approach where unsafe actions are overriden in favour of safe controls when the system approaches the boundary of the unsafe region.
        </p>

        <center>
            <img src="./resources/images/mppi_filter_v2.png" width="45%">
        </center>

        <hr>

        <center><h1>DualGuard MPPI</h1></center>

        <p align='justify'>
        While MPPI optimizes performance by sampling and refining control sequences, it does not guarantee safety as unsafe rollouts are penalized but still generated and discarded, wasting computation. Post-processing with safety filters can enforce constraints, but often sacrifices performance due to reactive corrections.
        </p>

        <p align='justify'>
        DualGuard MPPI addresses this by embedding safety enforcement into the MPPI loop through two key steps:
        </p>

        <ul>
          <li><b>Safe Rollouts:</b> Each sampled control sequence is filtered with a safety controller before rollout, ensuring all trajectories are safe and usable. This improves sample efficiency and performance consistency.</li>
          <li><b>Output Filtering:</b> After computing the optimal control sequence, we apply a final safety filter before execution. This guarantees that the applied command is safe, even in cases where safe trajectories are multimodal and might cancel each other out.</li>
        </ul>

        <p align='justify'>
        The full DualGuard MPPI algorithm combines both filtering layers into a provably safe and performant control strategy:
        </p>

        <center>
          <img src="./resources/images/alg_mppi_v2.png" width="45%">
        </center>

        <hr>

        <center><h1>Hardware Experiments – RC Car</h1></center>

        <p align="justify">
        We evaluate DualGuard MPPI on a miniature RC car executing aggressive laps around a physical racetrack. The car’s state \((x, y, \theta)\) evolves with the control input \(u = [V, \delta]\), where \(V \in [0.7, 1.4]\) m/s is the speed and \(\delta \in [-25^\circ, 25^\circ]\) is the steering angle. Disturbances \(d_x, d_y \in [-0.1, 0.1]\) capture model mismatch and sensor error:
        </p>

        <p align="center">\(\dot{x} = V \cos(\theta) + d_x,\quad \dot{y} = V \sin(\theta) + d_y,\quad \dot{\theta} = \frac{V \tan(\delta)}{L}\)</p>

        <p align="justify">
        To reflect real-time performance, we report: <b>Computation Time</b> (ms per control update), <b>Speed</b> (average m/s over three laps), and <b>RelCost</b> (normalized performance cost). Safety-violating episodes are marked as failures. The cost function penalizes deviation from track center, lower speeds, and safety violations:
        </p>

        <p align="center">\(S = (V_{max}-V)^2 + K_c (l_{center} - \phi(x)) + P(x)\)</p>

        <p align="justify">
        All methods were run at 50Hz using 1000 parallel rollouts per step on a laptop GPU (NVIDIA RTX 4060) using JAX. The value function and reachable set were precomputed using LevelSetToolbox[1].
        </p>

        <center>
          <video width="100%" controls>
            <source src="./resources/videos/dualguard_mppi_x4.mp4" type="video/mp4">
            Your browser does not support the video tag.
          </video>
          <p><i>Video: Comparison of methods, x4 playback speed.</i></p>
        </center>

        <center>
          <img src="./resources/images/dg_table_hw.png" width="60%">
        </center>

        <p align="justify">
        DualGuard MPPI completes the track safely and aggressively, outperforming other safety-aware methods in speed and cost. Unfiltered methods fail on tight turns despite high penalty weights, highlighting the importance of hard safety constraints. Our safe rollout stage improves sample quality, while the final filtering ensures guaranteed safety—even in multimodal scenarios. All methods remain under the 20ms compute budget.
        </p>

        <p align="justify">
        While the benefits of guaranteed safety are clearly visible in the hardware results, the improvements in sample efficiency introduced by our safe rollout mechanism are harder to observe in this single-task setting. These advantages along with broader comparisons and formulation details are thoroughly explored in the full paper linked at the top of this page.
        </p>


      <hr>
      
      <p>
        [1] I. Mitchell, “A toolbox of level set methods,” http://www.cs.ubc.ca/mitchell/ToolboxLS/toolboxLS. pdf, Tech. Rep. TR-2004-09, 2004.
      </p>
      <br>

      <table align=center width=1100px>
          <tr>
              <td>
                <left>
          <center><h1>Acknowledgements</h1></center>
          
          <br>
          This research is supported in part by the DARPA ANSR program and by NSF CAREER program (award number 2240163) and BECAS Chile.
          <br>
          <br>
          This webpage template was borrowed from some <a href="https://richzhang.github.io/colorization/">colorful folks</a>.
      </left>
  </td>
  </tr>
  </table>

  <br><br>
</body>
</html>
